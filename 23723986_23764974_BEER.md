# Battleships Project 

## Task 1 - Basic 2-Player Game with Concurrency in BEER     
**Task 1-1 - Concurrency Issue Fix:**              
In the initial client implementation,message syncronization issues occurred due to a single-threaded input/output model, this model forced the implementation to have to alternate between reading from the server to prompting for user input. This led to mutliple issues particularly with server message delays. We addressed this issue by implementing threading to add concurrency to the client.py implementation. To also improve function modularity we specifically added the receive_messages function which was designed to constantly read from the server - this was done by executing the function within a daemon thread which was created in main, which is responsible for gathering user input, and run concurrently with the receive_messages function. Our multithreaded client implementation ensures clients can receive messages at any time while simultaneously guaranteeing no server messages are missed which aligns with task 1-1's specifications.

```c
# client.py
def receive_messages(rfile):
    try:
        while True:
            line = rfile.readline()
            if not line:
                print("[INFO] Server disconnected.")
                break

            line = line.strip()

            if line == "GRID":
                # Begin reading board lines
                print("\n[Board]")
                while True:
                    board_line = rfile.readline()
                    if not board_line or board_line.strip() == "":
                        break
                    print(board_line.strip())
            else:
                # Normal message
                print(line)
    except Exception as e:
        print(f"[ERROR] An error occurred in the receive thread: {e}")

def main():
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.connect((HOST, PORT))
        rfile = s.makefile('r')
        wfile = s.makefile('w')
        
        receive_thread = threading.Thread(target=receive_messages, args=(rfile,), daemon=True).start()

        try:
            while True:
                user_input = input(">> ")
                wfile.write(user_input + '\n')
                wfile.flush()

        except KeyboardInterrupt:
            print("\n[INFO] Exiting...")

        finally:
            s.close()
```

**Task 1-2 - Accepting Two Connections:**       
The original server file design was only able to handle one client at a time and didn't make use of concurrency, to be able to comply with the task requirements of accepting two clients, we had to modify the server file to implement multi-threading. Using socket.accept in a while loop, our function waits until two clients are connected, then each accepted socket is wrapped using a read and write makefile. Once both clients are connected we store their connections in a list and start a new thread for them by calling the handle_clients function as the target and each client as its arguments. The handle_cients function handles the game between two connected players where each player is a tuple of their (conn, rfile, wfile), having this as a separate function called by main helped to improve the files modularity which aligns with task 1-2's requirements.    

```c
# server.py 
def handle_clients(player1, player2):
    """
    Handles the game between two connected players.
    Each player is a tuple of (conn, rfile, wfile).
    """
    print("[INFO] Starting two-player game...")

    # Extract readable/writable file objects
    rfile1, wfile1 = player1[1], player1[2]
    rfile2, wfile2 = player2[1], player2[2]

    run_two_player_game_online((rfile1, wfile1), (rfile2, wfile2))

    player1[0].close()
    player2[0].close()
    print("[INFO] Game over. Connections closed.")

def main():
    """
    Accepts exactly two clients, then starts the game.
    """
    print(f"[INFO] Server listening on {HOST}:{PORT}")
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.bind((HOST, PORT))
        s.listen(2)

        players = []

        while len(players) < 2:
            conn, addr = s.accept()
            print(f"[INFO] Player {len(players) + 1} connected from {addr}")
            rfile = conn.makefile('r')
            wfile = conn.makefile('w')
            players.append((conn, rfile, wfile))

        # Start game in a separate thread (optional, makes future expansion easier)
        threading.Thread(target=handle_clients, args=(players[0], players[1])).start()
```

**Task 1-3 - Implement Basic Game Mechanics:**        
The core game functionality was implemented within the run_two_player_game_online which was in the battleship file but is called within the server file. For this function we used the same style for our implementation of run_two_player_game_online as run_single_player_game_locally used, but enabling interaction between two remote players. This choice was made so we could maintain consistency in the codebase (i.e. using the same send, send_board and recv functions). The actual implementation of the battleship mechanics is as follows; prompt the current player for a coordinate -> validate input using parse_coordinate -> call fire_at on the opponents board -> send the outcome to both players -> end the game when all_ships_sunk is true. The turn switching is handled by toggling the current index and the game ends gracefully by printing a win/loss message for each client then closing their sockets.

```c
# battleship.py
def run_two_player_game_online(player1_io, player2_io):
    """
    Runs a turn-based Battleship game between two online players.
    Each player_io is a tuple of (rfile, wfile) file-like objects.
    """

    rfile1, wfile1 = player1_io
    rfile2, wfile2 = player2_io

    board1 = Board(BOARD_SIZE)
    board2 = Board(BOARD_SIZE)
    board1.place_ships_randomly(SHIPS)
    board2.place_ships_randomly(SHIPS)

def send(wfile, msg):
    wfile.write(msg + '\n')
    wfile.flush()

def send_board(wfile, board):
    wfile.write("GRID\n")
    wfile.write("  " + " ".join(str(i + 1).rjust(2) for i in range(board.size)) + '\n')
    for r in range(board.size):
        row_label = chr(ord('A') + r)
        row_str = " ".join(board.display_grid[r][c] for c in range(board.size))
        wfile.write(f"{row_label:2} {row_str}\n")
    wfile.write('\n')
    wfile.flush()

def recv(rfile):
    return rfile.readline().strip()

players = [
    {"name": "Player 1", "r": rfile1, "w": wfile1, "board": board2}, # Fires at player 2’s board
    {"name": "Player 2", "r": rfile2, "w": wfile2, "board": board1} # Fires at player 1’s board
]

for p in players:
    send(p["w"], f"Welcome {p['name']}! Game is starting now. Type 'quit' to exit.\n")

current = 0  # Index of current player
moves = [0, 0]  # Track moves per player

while True:
    p = players[current]
    opponent = players[1 - current]

    send_board(p["w"], p["board"])
    send(p["w"], "Your turn. Enter coordinate to fire at (e.g., B5):")

    guess = recv(p["r"])
    if guess.lower() == 'quit':
        send(p["w"], "You forfeited the game.")
        send(opponent["w"], "Opponent forfeited. You win!")
        break

    try:
        row, col = parse_coordinate(guess)
        result, sunk_name = p["board"].fire_at(row, col)
        moves[current] += 1

        if result == 'hit':
            if sunk_name:
                send(p["w"], f"HIT! You sank the {sunk_name}!")
                send(opponent["w"], f"{p['name']} sank your {sunk_name}!")
            else:
                send(p["w"], "HIT!")
                send(opponent["w"], f"{p['name']} hit one of your ships!")
            if p["board"].all_ships_sunk():
                send(p["w"], f"Congratulations! You sank all ships in {moves[current]} moves.")
                send(opponent["w"], "All your ships are sunk. You lose.")
                break
        elif result == 'miss':
            send(p["w"], "MISS!")
            send(opponent["w"], f"{p['name']} missed.")
            current = 1 - current  # Switch turns
        elif result == 'already_shot':
            send(p["w"], "You've already fired at that location. Try again.")
    except ValueError as e:
        send(p["w"], f"Invalid input: {e}")
```

**Task 1-4 - Client & Server Message Exchange:**        
The message exchange between the server / client currently follows a structured protocol using plain-text printed to the terminal. We chose this to maintain simplicity and readability for players. Client commands are sent as plain text and we make use of the recv function to parse the messages and the send function to write messages between the server / client. We tried to keep our client / server messages in the same style in the run_two_player_game_online function as the run_single_player_game_online function to maintain consistency and minimialism as specified within the task1-3 requirements.

```c
# battleship.py file
def send(wfile, msg):
        wfile.write(msg + '\n')
        wfile.flush()

def recv(rfile):
    return rfile.readline().strip()
```

**Task 1-5 - End Game Upon Disconnect:**       
In accordance with task 1-5, since we assume a stable connection, we have not actively handled disconnections in this implementation. Once the game is won or if a player disconnects / forfeits by typing quit, the game loop is exited and both connections are stopped by the server closing the sockets associated with each player using player1[0].close within the handle_clients function.

```c
# server.py file
run_two_player_game_online((rfile1, wfile1), (rfile2, wfile2))

player1[0].close()
player2[0].close()
print("[INFO] Game over. Connections closed.")
```
   
## Task 2 - Gameplay Quality-of-Life & Scalability     
**Task 2-1 - Input Validation:**         
To meet the Tier 2-1 requirements, we added several layers of input validation to ensure server stability and user feedback for invalid actions. We guarantee turn enforcement by making sure input is only read from the player whose turn it is. This means that the other player cannot interfere out-of-turn due to the sequential structure of the server’s main loop. which is created by using the ```p = players[current]``` and ```opponent = players[1 - current]``` code to define the players. Additionally, we explicitly notify the current player that it is their turn with the message "It's your turn! Enter a coordinate to fire at (e.g., B5):" and inform the opponent with "Waiting for [Player Name] to take their turn..." to reduce confusion and discourage out-of-turn actions. We account for empty input such that if a player (accidentally) sends an empy message by pressing the enter key without entering any coordinate, our server implementation will respond with "No input received. Please enter a coordinate like B5." As demonstrated in the *if not guess* block. We've also handled coordinates enter tht have an invalid format using a try -> except block around the parse coordinates function which will raise a *ValueError* if there is an error which prevents our battleship prgrom from crashing. Finally, we accounted for clients (players) trying to take multiple shots in the same turn by stopping the behaviour; as soon as a valid input is received it breaks the inner loop and ```current = 1 - current``` changes it to be the other players turn, thus not allowing a player to take a second shot out of turn. These input validation checks align with the requirements of task 2-1.

```c
# battleship.py
while True: # Outer loop: Manages the game flow
    p = players[current]
    opponent = players[1 - current]

    send(p["w"], "It's your turn! Enter a coordinate to fire at (e.g., B5):")
    send(opponent["w"], f"Waiting for {p['name']} to take their turn...")

    send_board(p["w"], p["board"])

    while True: # Inner loop: Handles input and game logic
        guess = recv(p["r"]).strip()
        if not guess:
            send(p["w"], "No input received. Please enter a coordinate like B5.")
            continue

        if guess.lower() == 'quit':
            send(p["w"], "You forfeited the game.")
            send(opponent["w"], "Opponent forfeited. You win!")
            return

        try:
            row, col = parse_coordinate(guess)
            result, sunk_name = p["board"].fire_at(row, col)
            moves[current] += 1

            if result == 'hit':
                if sunk_name:
                    send(p["w"], f"HIT! You sank the {sunk_name}!")
                    send(opponent["w"], f"{p['name']} sank your {sunk_name}!")
                else:
                    send(p["w"], "HIT!")
                    send(opponent["w"], f"{p['name']} hit one of your ships!")
                if p["board"].all_ships_sunk():
                    send(p["w"], f"Congratulations! You sank all ships in {moves[current]} moves.")
                    send(opponent["w"], "All your ships are sunk. You lose.")
                    return # Ends the game if all ships are sunk
            elif result == 'miss':
                send(p["w"], "MISS!")
                send(opponent["w"], f"{p['name']} missed.")
            elif result == 'already_shot':
                send(p["w"], "You've already fired at that location. Try again.")
                continue # Lets the player try again

            break
        except ValueError as e:
            send(p["w"], f"Invalid input: {e}")
    
    current = 1 - current  # Switches turns after each valid shot
```

**Task 2-2 - Multiple Game Support:**          
To meet the Tier 2-2 requirements, we nested the `run_single_player_game_locally()` function in an infinite loop such that game play continues so long as the user responds "yes" when the system prompts a user to play another game. The initial server process is used until a user response "no", in which case `python3 battleship.py` will need to be executed and the server will restart with new connections. 

Similarly, for 2-player games, the function `run_two_player_game_online()` is nested in an infinite loop inside a handler function `handle_clients()` in `server.py`. Once a game ends, either due to a player quitting or the a player winning, both users are prompted by the server to play on. If either user response "no" then the infinite loop breaks and the connections to the server are terminated. If both users response "yes" then the infinite loop continues and the game restarts on the same server instance. To implement this logic, we also moved the functions `send()` and `recv()` into the global scope so they can be imported into `server.py` and reused to prompt users and store their responses.

Two implement the optional confirmation step, we returned the current board to both users when a game is exited, both when a player wins or when a player quits the game.

logic for single player game
```c
# battleship.py
def main():
    while True:
        run_single_player_game_locally()
        
        response = input("Play again? (yes/no): ").strip().lower()
        if response != 'yes':
            print("Thanks for playing!")
            break
```

logic for two player game
```c
# server.py
def handle_clients(player1, player2):
    """
    Handles the game between two connected players.
    Each player is a tuple of (conn, rfile, wfile).
    """
    print("[INFO] Starting two-player game...")

    # Extract readable/writable file objects
    rfile1, wfile1 = player1[1], player1[2]
    rfile2, wfile2 = player2[1], player2[2]

    while True:
        run_two_player_game_online((rfile1, wfile1), (rfile2, wfile2))

        # Ask if they want to play again
        send(wfile1, "[INFO] Game over. Do you want to play again? (yes/no)")
        send(wfile2, "[INFO] Game over. Do you want to play again? (yes/no)")

        response1 = recv(rfile1).strip().lower()
        response2 = recv(rfile2).strip().lower()

        if response1 != "yes" or response2 != "yes":
            send(wfile1, "[INFO] Game ended. Thanks for playing!")
            send(wfile2, "[INFO] Game ended. Thanks for playing!")

            player1[0].close()
            player2[0].close()

            print("[INFO] Players disconnected.")
            break
```

logic for confirmation step
```c
# battleship.py
def run_two_player_game_online(player1_io, player2_io):
    ...

            if guess.lower() == 'quit':
                send(p["w"], "You forfeited the game.")
                send(opponent["w"], "Opponent forfeited. You win!")
                
                # Send final boards to both players
                send_board(p["w"], p["board"])
                send_board(opponent["w"], opponent["board"])
                return

            try:
                row, col = parse_coordinate(guess)
                result, sunk_name = p["board"].fire_at(row, col)
                moves[current] += 1

                if result == 'hit':
                    if sunk_name:
                        send(p["w"], f"HIT! You sank the {sunk_name}!")
                        send(opponent["w"], f"{p['name']} sank your {sunk_name}!")
                    else:
                        send(p["w"], "HIT!")
                        send(opponent["w"], f"{p['name']} hit one of your ships!")
                    if p["board"].all_ships_sunk():
                        send(p["w"], f"Congratulations! You sank all ships in {moves[current]} moves.")
                        send(opponent["w"], "All your ships are sunk. You lose.")

                        # Send final boards to both players
                        send_board(p["w"], p["board"])
                        send_board(opponent["w"], opponent["board"])
                        return # Ends the game if all ships are sunk

```

**Task 2-3 - Timeout Handling:**        
To meet the Tier 2.3 requirement we created the local function `timed_input()` within the `run_single_player_game_locally()` and `run_two_player_game_online()` functions to handle timing the current turn of each player. The global variable `TIMEOUT` is set to equal 30 seconds, and defines the modest inactivity timer which, when exhausted by the current player, terminates the game and skips the players turn in the single and two player versions of the game respectively. 

In the single player game, the server is sent input from the command line by prompting the client to enter a coordinate. In the original implementation with no timeout handling, the user is prompted using the inbuilt `input()` function. The modified `timed_input()` function uses the `input()` function as a parameter of a `Thread` object which starts counting and joins the main thread after the specified `TIMEOUT` period (30 seconds). If the input thread is still alive, then the `timed_input()` function must still be waiting for the user's input and therefore they have exhausted the timeout period and the game should be terminated. The outer `run_single_player_game_locally()` function handles the game termination by checking if guess (which is the value returned by `timed_input()` is `None`, if it is `None` the outer function returns nothing to the `main()` function and the game is ended. 

```c
# battleship.py
def run_single_player_game_locally():
    """
    A test harness for local single-player mode, demonstrating two approaches:
     1) place_ships_manually()
     2) place_ships_randomly()

    Then the player tries to sink them by firing coordinates.
    """

    def timed_input(prompt):
        def get_input():
            global user_input
            user_input = input(prompt)

        thread = threading.Thread(target=get_input, daemon=True)
        thread.start()
        thread.join(TIMEOUT)

        if thread.is_alive():
            return None # timout reached
        else: 
            return user_input

    while True:
        board.print_display_grid()
        guess = timed_input("\nEnter coordinate to fire at (or 'quit'): ")
        
        if guess is None:
            print("\nGame Over! You took too long to respond.")
            return # end game
```

Similarly, in the `run_two_player_game_online()` function the `timed_input()` function uses a `worker()` function based on the previously defined `recv()` function which reads a line from the provided socket input (rfile). If the reading fails, it stores `None` - this indicates that there has not been any user input. A new background thread is started to run this `worker()` function and joins the main thread after the `TIMEOUT` period (30 seconds). If the thread is still alive, the timeout period has been exhausted so the `timed_input()` function returns `None`, otherwise whatever was read in from the client is returned. The outer function `run_two_player_game_online()` skips the current players turn when the `guess` (the return value of `timed_input()`) is `None` by breaking the infinite loop and switching the current player index (using `current = 1 - current`). The background thread and timing mechanism addresses the requirement of timeout handling. 

```c
# battleship.py
def run_two_player_game_online(player1_io, player2_io):
    """
    Runs a turn-based Battleship game between two online players.
    Each player_io is a tuple of (rfile, wfile) file-like objects.
    """
    def timed_input(rfile, timeout=TIMEOUT):
        result = {}

        def worker():
            try:
                result['data'] = rfile.readline().strip()
            except Exception:
                result['data'] = None

        thread = threading.Thread(target=worker, daemon=True)
        thread.start()
        thread.join(timeout)

        if thread.is_alive():
            return None # timeout reaches
        else:
            return result.get('data', None)

    ...
    while True: # Outer loop: Manages the game flow
    p = players[current]
    opponent = players[1 - current]

    send(p["w"], "It's your turn! Enter a coordinate to fire at (e.g., B5):")
    send(opponent["w"], f"Waiting for {p['name']} to take their turn...")

    send_board(p["w"], p["board"])

    while True: # Inner loop: Handles input and game logic
        guess = timed_input(p["r"])

        if guess is None:
            send(p["w"], "Time's up! You took too long to respond.\n")
            send(opponent["w"], f"{p['name']} took too long.\n")
            break  # forfeit turn
    ...
```

**Task 2-4 - Disconnection Handling:**         
...
```c
```

**Task 2-5 - Adding Waiting Lobby:**         
...
```c
```

## Task 3 - Multiple Connections     
**Task 3-1 - Accepting More Than Two Connections:**         
The changes made allow spectators to view the game state by introducing the broadcast_to_spectators function, which sends game state updates to all connected spectators. This function is called within the run_two_player_game_online function in battleship.py via a callback mechanism, ensuring that spectators receive updates after each turn. The lobby_manager function was updated to correctly add extra clients to the spectators list when the lobby is full or a game is in progress. Additionally, disconnected spectators are removed from the list to maintain stability. These changes ensure that spectators are seamlessly integrated into the game flow and can observe the game's progress in real-time.

```c
# server.py
def broadcast_to_spectators(game_state):
    """
    Sends the current game state to all connected spectators.
    """
    with lobby_lock:
        for conn, rfile, wfile in spectators:
            try:
                send(wfile, f"[SPECTATOR] Game state update:\n{game_state}")
            except:
                # Remove disconnected spectators
                spectators.remove((conn, rfile, wfile))
```

```c
# battleship.py
def broadcast_game_state_to_spectators(players):
        """
        Broadcast the current game state to all spectators.
        """
        game_state = []
        for p in players:
            board_state = f"{p['name']}'s Board:\n"
            board_state += "  " + " ".join(str(i + 1).rjust(2) for i in range(p["board"].size)) + '\n'
            for r in range(p["board"].size):
                row_label = chr(ord('A') + r)
                row_str = " ".join(p["board"].display_grid[r][c] for c in range(p["board"].size))
                board_state += f"{row_label:2} {row_str}\n"
            game_state.append(board_state)
        broadcast_callback("\n\n".join(game_state))
```

**Task 3-2 - Spectator Game Updates:**         
The changes made ensure that spectators receive real-time updates about the game state, including board updates, shots fired, hits/misses, and the final outcome. The broadcast_game_state_to_spectators function was updated to include a message parameter, allowing event-specific messages (e.g., "HIT!", "MISS!", or "Game over.") to be broadcast alongside the updated boards. This function is now called after every significant event, such as a hit, miss, or game-ending condition, ensuring spectators are fully informed. Additionally, proper handling of invalid inputs and repeated shots was implemented to maintain game integrity and provide clear feedback to players. These changes enhance the spectator experience while preserving the core gameplay mechanics.

```c
# server.py
def handle_spectator_input(rfile, wfile):
    """
    Handles input from spectators. Any input is ignored or produces an error message.
    """
    try:
        while True:
            command = rfile.readline().strip()
            if command:
                send(wfile, "[ERROR] Spectators cannot issue commands.")
    except Exception:
        pass
```

```c
# battleship.py
def broadcast_game_state_to_spectators(players, message):
        """
        Broadcast the current game state to all spectators.
        """
        game_state = []
        for p in players:
            board_state = f"{p['name']}'s Board:\n"
            board_state += "  " + " ".join(str(i + 1).rjust(2) for i in range(p["board"].size)) + '\n'
            for r in range(p["board"].size):
                row_label = chr(ord('A') + r)
                row_str = " ".join(p["board"].display_grid[r][c] for c in range(p["board"].size))
                board_state += f"{row_label:2} {row_str}\n"
            game_state.append(board_state)
        
        full_message = f"{message}\n\n" + "\n\n".join(game_state)
        broadcast_callback(full_message)
```

**Task 3-3 - Reconnection Support:**          
The code fulfills the T3.3 Reconnection Support requirements by implementing a reconnection mechanism for a two-player online game. Each player is asked to enter a username upon initial connection, which serves as a unique identifier and enables the system to recognize returning players. When a disconnection occurs, the server detects which player has dropped and records the disconnection time. It then enters a reconnection window, waiting up to a predefined timeout (e.g., 60 seconds) for the player to reconnect. During this period, the player’s still_active flag is monitored to detect successful reconnection. If the player returns within the allowed timeframe, the game state—consisting of both boards, the current turn, and the move history—is restored using the initial_state parameter, allowing the game to resume seamlessly. If the player fails to reconnect within the timeout or if the opponent wins during the disconnection, the game does not resume for the disconnected player. This ensures fairness and continuity without delaying the gameplay experience for the other participant.

```c
# battleship.py
def run_two_player_game_online(player1_io, player2_io, broadcast_callback, save_state_callback, player1_id, player2_id, initial_state=None):
    """
    Runs a turn-based Battleship game between two online players.
    Each player_io is a tuple of (rfile, wfile) file-like objects.
    """

    rfile1, wfile1 = player1_io
    rfile2, wfile2 = player2_io

    if initial_state:
        board1 = initial_state['board1']    
        board2 = initial_state['board2']         
        current = initial_state['turn']     
        moves = [                                     
            initial_state['moves']['Player 1'], 
            initial_state['moves']['Player 2'] 
        ]

    else:
        board1 = Board(BOARD_SIZE)
        board2 = Board(BOARD_SIZE)
        board1.place_ships_randomly(SHIPS)
        board2.place_ships_randomly(SHIPS)
        current = 0  # Index of current player
        moves = [0, 0]  # Track moves per player
```

```c
# server.py
except (KeyboardInterrupt, ConnectionResetError, BrokenPipeError, OSError):
            print("[WARNING] A player disconnected unexpectedly. Handling disconnection...")
            disconnected, opponent = None, None
            try:
                send(wfile1, "[PING]")
                player1_connected = True
            except:
                player1_connected = False

            try:
                send(wfile2, "[PING]")
                player2_connected = True
            except:
                player2_connected = False

            if not player1_connected:
                disconnected, opponent = username1, (conn2, rfile2, wfile2, username2)
            else:
                disconnected, opponent = username2, (conn1, rfile1, wfile1, username1)

            active_players[disconnected]['still_active'] = False
            active_players[disconnected]['disconnect_time'] = time.time()

            for _ in range(RECONNECT_TIMEOUT):
                time.sleep(1)
                if active_players[disconnected]['still_active']:
                    print(f"[INFO] {disconnected} has reconnected. Resuming game.")
                    did_resume = True
                    re_p1, re_p2 = current_match[disconnected]
                    # Determine which I/O tuple belongs to reconnecting player
                    if re_p1[3] == disconnected:
                        player1, player2 = (rfile1, wfile1), (rfile2, wfile2)
                    else:
                        player1, player2 = (rfile2, wfile2), (rfile1, wfile1)

                    run_two_player_game_online(player1, player2, broadcast_to_spectators, save_game_state, 
                                               username1, username2,
                                               initial_state=game_states.get(disconnected))
                    break
```

```c
# server.py
def lobby_manager(conn, addr):
    """
    Manages lobby for players waiting to join a game. 
    """
    print(f"[INFO] New client connected from {addr}")
    rfile = conn.makefile('r')
    wfile = conn.makefile('w')


    send(wfile, "[INFO] Welcome! Please enter your username:")
    username = recv(rfile).strip()

    # Handle reconnecting players
    send(wfile, "[INFO] Checking for any ongoing games...")
    if username in active_players and not active_players[username]['still_active'] and game_lock.locked():
        print(f"[INFO] {username} attempting to reconnect...")
        active_players[username]['still_active'] = True
        p1, p2 = current_match[username]
        # determine which tuple is theirs
        if p1[3] == username:
            resume_self, resume_opp = (conn, rfile, wfile, username), p2
        else:
            resume_self, resume_opp = (conn, rfile, wfile, username), p1
        send(wfile, "[INFO] Reconnected! Waiting for game to resume...")
        threading.Thread(target=run_two_player_game_online,
            args=((resume_self[1], resume_self[2]), (resume_opp[1], resume_opp[2]),
                broadcast_to_spectators,
                save_game_state,
                p1[3], p2[3]
            ),
            kwargs={'initial_state': game_states.get(username)},
            daemon=True
        ).start()
        return
```

**Task 3-4 - First In First Out Lobby:**           
The code addresses the requirements of Task 3.4 – First In First Out Lobby – by implementing a transition mechanism from one match to the next. The launch_game_if_ready() function checks whether at least two players are waiting in the lobby and confirms that no game is currently active by checking if the game_lock is unlocked. It then removes the first two players from the lobby list in the order they joined, ensuring a first-come-first-served policy. Each selected player receives a message via their write file confirming the match pairing and informing them that the game is about to start. Furthermore, the function calls stop_spectator_thread() for both players, which helps isolate active participants from spectators or previously disconnected clients, preventing outside interference with the current match. This structure guarantees a clean transition between matches and maintains fairness in player selection.

```c
# server.py
def launch_game_if_ready():
    with lobby_lock:
        if len(lobby) >= 2 and not game_lock.locked():
            player1 = lobby.pop(0)
            player2 = lobby.pop(0)

            for entry in [player1, player2]:
                conn, rfile, wfile, user = entry
                send(wfile, f"[INFO] {player1[3]} and {player2[3]} will be playing the next game!")

            stop_spectator_thread(player1[3])
            stop_spectator_thread(player2[3])
```

## Task 4 - Advanced Features
**Task 4-1 - Checksum Implementation:**          
The provided code implements a CRC-32 checksum mechanism to detect and handle corrupted packets during communication between a client and server, fulfilling the specified reliability requirements. Each message sent includes a CRC-32 checksum, appended using the format message|checksum, where the checksum is generated with zlib.crc32() and ensures 32-bit integrity protection. On receipt, the recv_with_checksum() function splits the message to extract and verify the checksum. If the computed checksum does not match the received one, the packet is silently discarded, preventing corrupted data from reaching the application logic. This simple yet effective error-handling policy avoids processing invalid data, maintaining robust communication without complex retransmission protocols. The packet structure is clearly defined: the message content is followed by a pipe (|) separator and a 32-bit checksum. Verification on the client side is similarly handled using the verify_checksum() function, ensuring two-way integrity checks. While retransmission mechanisms could enhance reliability further, the current discard policy simplifies the implementation which is suitable for our implementation.  

```c
# client.py
def generate_crc32_checksum(data):
    return zlib.crc32(data) & 0xFFFFFFFF


def verify_checksum(message, expected_checksum):
    message_data, checksum_str = message.rsplit('|', 1)
    checksum = int(checksum_str)
    computed_checksum = generate_crc32_checksum(message_data.encode())
    return checksum == computed_checksum
```
```c
# server.py
def send_with_checksum(wfile, message):
    """
    Send a message with a checksum attached to the client.
    """
    checksum = zlib.crc32(message.encode())
    message_with_checksum = f"{message}|{checksum}"
    wfile.write(message_with_checksum + '\n')
    wfile.flush()


def recv_with_checksum(rfile):
    """
    Receive a message with checksum from the client and verify its integrity.
    """
    message_with_checksum = rfile.readline().strip()
    try:
        message, received_checksum = message_with_checksum.rsplit('|', 1) 
        calculated_checksum = zlib.crc32(message.encode())  
        
        if int(received_checksum) == calculated_checksum: 
            return message
    except:
        pass  # Silently discard any malformed or invalid messages
    return None
```

**Task 4-3 - Encryption & Decryption:**       
The implemented encryption scheme uses AES in CTR (Counter) mode with a static 256-bit shared secret key to provide confidentiality for messages exchanged between the client and server, satisfying the encryption layer requirements. Each message is encrypted with a unique 128-bit initialization vector (IV), generated using get_random_bytes(16), which ensures semantic security and prevents replay attacks by making ciphertexts unique even when plaintexts repeat. The IV is prepended to the ciphertext before being Base64-encoded and transmitted, allowing the receiver to reconstruct the correct counter for decryption. This design assumes a secure, out-of-band channel for sharing the static key, simplifying key management in a controlled environment. The encrypted payload fits seamlessly into the custom packet structure, where the payload (excluding the checksum) is encrypted, and the checksum can still be verified by computing it over the plaintext after decryption. Replay attacks are mitigated by using fresh IVs for each encryption, and partial packet corruption is addressed by the combination of decryption failure (e.g., decoding errors) and checksum verification, both of which will reject tampered data.    

```c
# battleship.py
def timed_input(rfile, timeout=TIMEOUT):
    result = {}

    def worker():
        try:
            raw_data = rfile.readline().strip()
            encrypted_msg = raw_data.split('|')[0]
            decrypted_msg = decrypt_message(encrypted_msg)
            result['data'] = decrypted_msg
        except Exception:
            result['data'] = None
```
```c
# crypto_utlis.py
from Crypto.Cipher import AES
from Crypto.Util import Counter
from Crypto.Random import get_random_bytes
import os
import base64

# Shared secret key (32 bytes = 256-bit key)
SECRET_KEY = b'ThisIsAStaticKeyForTesting123456'

def encrypt_message(message: str) -> str:
    iv = get_random_bytes(16)  # 128-bit IV
    ctr = Counter.new(128, initial_value=int.from_bytes(iv, byteorder='big')) # new ctr each time as per AES CTR mode 
    cipher = AES.new(SECRET_KEY, AES.MODE_CTR, counter=ctr)
    ciphertext = cipher.encrypt(message.encode('utf-8'))
    encrypted_data = iv + ciphertext
    return base64.b64encode(encrypted_data).decode('utf-8') # message is a string

def decrypt_message(data: str) -> str:
    # Ensure correct padding
    missing_padding = len(data) % 4
    if missing_padding != 0:
        data += '=' * (4 - missing_padding)
    
    raw_data = base64.b64decode(data.encode('utf-8'))
    iv = raw_data[:16]
    ciphertext = raw_data[16:]
    ctr = Counter.new(128, initial_value=int.from_bytes(iv, byteorder='big'))
    cipher = AES.new(SECRET_KEY, AES.MODE_CTR, counter=ctr)
    plaintext = cipher.decrypt(ciphertext).decode('utf-8')
    return plaintext
```

**Task 4-4 - Security Flaws & Mitigations:**       
...
