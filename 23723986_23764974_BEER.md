# Battleships Project 

## Task 1 - Basic 2-Player Game with Concurrency in BEER     
Task 1-1:    
In the initial client implementation,message syncronization issues occurred due to a single-threaded input/output model, this model forced the implementation to have to alternate between reading from the server to prompting for user input. This led to mutliple issues particularly with server message delays. We addressed this issue by implementing threading to add concurrency to the client.py implementation. To also improve function modularity we specifically added the receive_messages function which was designed to constantly read from the server - this was done by executing the function within a daemon thread which was created in main, which is responsible for gathering user input, and run concurrently with the receive_messages function. Our multithreaded client implementation ensures clients can receive messages at any time while simultaneously guaranteeing no server messages are missed which aligns with task 1-1's specifications.

```
# client.py file
def receive_messages(rfile):
    try:
        while True:
            line = rfile.readline()
            if not line:
                print("[INFO] Server disconnected.")
                break

            line = line.strip()

            if line == "GRID":
                # Begin reading board lines
                print("\n[Board]")
                while True:
                    board_line = rfile.readline()
                    if not board_line or board_line.strip() == "":
                        break
                    print(board_line.strip())
            else:
                # Normal message
                print(line)
    except Exception as e:
        print(f"[ERROR] An error occurred in the receive thread: {e}")

def main():
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.connect((HOST, PORT))
        rfile = s.makefile('r')
        wfile = s.makefile('w')
        
        receive_thread = threading.Thread(target=receive_messages, args=(rfile,), daemon=True).start()

        try:
            while True:
                user_input = input(">> ")
                wfile.write(user_input + '\n')
                wfile.flush()

        except KeyboardInterrupt:
            print("\n[INFO] Exiting...")

        finally:
            s.close()
```

Task 1-2:   
The original server file design was only able to handle one client at a time and didn't make use of concurrency, to be able to comply with the task requirements of accepting two clients, we had to modify the server file to implement multi-threading. Using socket.accept in a while loop, our function waits until two clients are connected, then each accepted socket is wrapped using a read and write makefile. Once both clients are connected we store their connections in a list and start a new thread for them by calling the handle_clients function as the target and each client as its arguments. The handle_cients function handles the game between two connected players where each player is a tuple of their (conn, rfile, wfile), having this as a separate function called by main helped to improve the files modularity which aligns with task 1-2's requirements.    

```
# server.py file
def handle_clients(player1, player2):
    """
    Handles the game between two connected players.
    Each player is a tuple of (conn, rfile, wfile).
    """
    print("[INFO] Starting two-player game...")

    # Extract readable/writable file objects
    rfile1, wfile1 = player1[1], player1[2]
    rfile2, wfile2 = player2[1], player2[2]

    run_two_player_game_online((rfile1, wfile1), (rfile2, wfile2))

    player1[0].close()
    player2[0].close()
    print("[INFO] Game over. Connections closed.")

def main():
    """
    Accepts exactly two clients, then starts the game.
    """
    print(f"[INFO] Server listening on {HOST}:{PORT}")
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.bind((HOST, PORT))
        s.listen(2)

        players = []

        while len(players) < 2:
            conn, addr = s.accept()
            print(f"[INFO] Player {len(players) + 1} connected from {addr}")
            rfile = conn.makefile('r')
            wfile = conn.makefile('w')
            players.append((conn, rfile, wfile))

        # Start game in a separate thread (optional, makes future expansion easier)
        threading.Thread(target=handle_clients, args=(players[0], players[1])).start()
```

Task 1-3:  
The core game functionality was implemented within the run_two_player_game_online which was in the battleship file but is called within the server file. For this function we used the same style for our implementation of run_two_player_game_online as run_single_player_game_locally used, but enabling interaction between two remote players. This choice was made so we could maintain consistency in the codebase (i.e. using the same send, send_board and recv functions). The actual implementation of the battleship mechanics is as follows; prompt the current player for a coordinate -> validate input using parse_coordinate -> call fire_at on the opponents board -> send the outcome to both players -> end the game when all_ships_sunk is true. The turn switching is handled by toggling the current index and the game ends gracefully by printing a win/loss message for each client then closing their sockets.

```
# battleship.py file
def run_two_player_game_online(player1_io, player2_io):
    """
    Runs a turn-based Battleship game between two online players.
    Each player_io is a tuple of (rfile, wfile) file-like objects.
    """

    rfile1, wfile1 = player1_io
    rfile2, wfile2 = player2_io

    board1 = Board(BOARD_SIZE)
    board2 = Board(BOARD_SIZE)
    board1.place_ships_randomly(SHIPS)
    board2.place_ships_randomly(SHIPS)

def send(wfile, msg):
    wfile.write(msg + '\n')
    wfile.flush()

def send_board(wfile, board):
    wfile.write("GRID\n")
    wfile.write("  " + " ".join(str(i + 1).rjust(2) for i in range(board.size)) + '\n')
    for r in range(board.size):
        row_label = chr(ord('A') + r)
        row_str = " ".join(board.display_grid[r][c] for c in range(board.size))
        wfile.write(f"{row_label:2} {row_str}\n")
    wfile.write('\n')
    wfile.flush()

def recv(rfile):
    return rfile.readline().strip()

players = [
    {"name": "Player 1", "r": rfile1, "w": wfile1, "board": board2}, # Fires at player 2’s board
    {"name": "Player 2", "r": rfile2, "w": wfile2, "board": board1} # Fires at player 1’s board
]

for p in players:
    send(p["w"], f"Welcome {p['name']}! Game is starting now. Type 'quit' to exit.\n")

current = 0  # Index of current player
moves = [0, 0]  # Track moves per player

while True:
    p = players[current]
    opponent = players[1 - current]

    send_board(p["w"], p["board"])
    send(p["w"], "Your turn. Enter coordinate to fire at (e.g., B5):")

    guess = recv(p["r"])
    if guess.lower() == 'quit':
        send(p["w"], "You forfeited the game.")
        send(opponent["w"], "Opponent forfeited. You win!")
        break

    try:
        row, col = parse_coordinate(guess)
        result, sunk_name = p["board"].fire_at(row, col)
        moves[current] += 1

        if result == 'hit':
            if sunk_name:
                send(p["w"], f"HIT! You sank the {sunk_name}!")
                send(opponent["w"], f"{p['name']} sank your {sunk_name}!")
            else:
                send(p["w"], "HIT!")
                send(opponent["w"], f"{p['name']} hit one of your ships!")
            if p["board"].all_ships_sunk():
                send(p["w"], f"Congratulations! You sank all ships in {moves[current]} moves.")
                send(opponent["w"], "All your ships are sunk. You lose.")
                break
        elif result == 'miss':
            send(p["w"], "MISS!")
            send(opponent["w"], f"{p['name']} missed.")
            current = 1 - current  # Switch turns
        elif result == 'already_shot':
            send(p["w"], "You've already fired at that location. Try again.")
    except ValueError as e:
        send(p["w"], f"Invalid input: {e}")
```

Task 1-4:   
The message exchange between the server / client currently follows a structured protocol using plain-text printed to the terminal. We chose this to maintain simplicity and readability for players. Client commands are sent as plain text and we make use of the recv function to parse the messages and the send function to write messages between the server / client. We tried to keep our client / server messages in the same style in the run_two_player_game_online function as the run_single_player_game_online function to maintain consistency and minimialism as specified within the task1-3 requirements.

```
# battleship.py file
def send(wfile, msg):
        wfile.write(msg + '\n')
        wfile.flush()

def recv(rfile):
    return rfile.readline().strip()
```

Task 1-5:   
In accordance with task 1-5, since we assume a stable connection, we have not actively handled disconnections in this implementation. Once the game is won or if a player disconnects / forfeits by typing quit, the game loop is exited and both connections are stopped by the server closing the sockets associated with each player using player1[0].close within the handle_clients function.

```
# server.py file
run_two_player_game_online((rfile1, wfile1), (rfile2, wfile2))

player1[0].close()
player2[0].close()
print("[INFO] Game over. Connections closed.")
```
   
## Task 2 - Gameplay Quality-of-Life & Scalability     
Task 2-1:   
To meet the Tier 2-1 requirements, we added several layers of input validation to ensure server stability and user feedback for invalid actions. We guarantee turn enforcement by making sure input is only read from the player whose turn it is. This means that the other player cannot interfere out-of-turn due to the sequential structure of the server’s main loop. which is created by using the ```p = players[current]``` and ```opponent = players[1 - current]``` code to define the players. Additionally, we explicitly notify the current player that it is their turn with the message "It's your turn! Enter a coordinate to fire at (e.g., B5):" and inform the opponent with "Waiting for [Player Name] to take their turn..." to reduce confusion and discourage out-of-turn actions. We account for empty input such that if a player (accidentally) sends an empy message by pressing the enter key without entering any coordinate, our server implementation will respond with "No input received. Please enter a coordinate like B5." As demonstrated in the *if not guess* block. We've also handled coordinates enter tht have an invalid format using a try -> except block around the parse coordinates function which will raise a *ValueError* if there is an error which prevents our battleship prgrom from crashing. Finally, we accounted for clients (players) trying to take multiple shots in the same turn by stopping the behaviour; as soon as a valid input is received it breaks the inner loop and ```current = 1 - current``` changes it to be the other players turn, thus not allowing a player to take a second shot out of turn. These input validation checks align with the requirements of task 2-1.
```
# battleship.py
while True: # Outer loop: Manages the game flow
    p = players[current]
    opponent = players[1 - current]

    send(p["w"], "It's your turn! Enter a coordinate to fire at (e.g., B5):")
    send(opponent["w"], f"Waiting for {p['name']} to take their turn...")

    send_board(p["w"], p["board"])

    while True: # Inner loop: Handles input and game logic
        guess = recv(p["r"]).strip()
        if not guess:
            send(p["w"], "No input received. Please enter a coordinate like B5.")
            continue

        if guess.lower() == 'quit':
            send(p["w"], "You forfeited the game.")
            send(opponent["w"], "Opponent forfeited. You win!")
            return

        try:
            row, col = parse_coordinate(guess)
            result, sunk_name = p["board"].fire_at(row, col)
            moves[current] += 1

            if result == 'hit':
                if sunk_name:
                    send(p["w"], f"HIT! You sank the {sunk_name}!")
                    send(opponent["w"], f"{p['name']} sank your {sunk_name}!")
                else:
                    send(p["w"], "HIT!")
                    send(opponent["w"], f"{p['name']} hit one of your ships!")
                if p["board"].all_ships_sunk():
                    send(p["w"], f"Congratulations! You sank all ships in {moves[current]} moves.")
                    send(opponent["w"], "All your ships are sunk. You lose.")
                    return # Ends the game if all ships are sunk
            elif result == 'miss':
                send(p["w"], "MISS!")
                send(opponent["w"], f"{p['name']} missed.")
            elif result == 'already_shot':
                send(p["w"], "You've already fired at that location. Try again.")
                continue # Lets the player try again

            break
        except ValueError as e:
            send(p["w"], f"Invalid input: {e}")
    
    current = 1 - current  # Switches turns after each valid shot
```

Task 2-2:   
To meet the Tier 2-2 requirements, we nested the `run_single_player_game_locally()` function in an infinite loop such that game play continues so long as the user responds "yes" when the system prompts a user to play another game. The initial server process is used until a user response "no", in which case `python3 battleship.py` will need to be executed and the server will restart with new connections. 

Similarly, for 2-player games, the function `run_two_player_game_online()` is nested in an infinite loop inside a handler function `handle_clients()` in `server.py`. Once a game ends, either due to a player quitting or the a player winning, both users are prompted by the server to play on. If either user response "no" then the infinite loop breaks and the connections to the server are terminated. If both users response "yes" then the infinite loop continues and the game restarts on the same server instance. To implement this logic, we also moved the functions `send()` and `recv()` into the global scope so they can be imported into `server.py` and reused to prompt users and store their responses.

Two implement the optional confirmation step, we returned the current board to both users when a game is exited, both when a player wins or when a player quits the game.

logic for single player game
```
# battleship.py
def main():
    while True:
        run_single_player_game_locally()
        
        response = input("Play again? (yes/no): ").strip().lower()
        if response != 'yes':
            print("Thanks for playing!")
            break
```

logic for two player game
```
# server.py
def handle_clients(player1, player2):
    """
    Handles the game between two connected players.
    Each player is a tuple of (conn, rfile, wfile).
    """
    print("[INFO] Starting two-player game...")

    # Extract readable/writable file objects
    rfile1, wfile1 = player1[1], player1[2]
    rfile2, wfile2 = player2[1], player2[2]

    while True:
        run_two_player_game_online((rfile1, wfile1), (rfile2, wfile2))

        # Ask if they want to play again
        send(wfile1, "[INFO] Game over. Do you want to play again? (yes/no)")
        send(wfile2, "[INFO] Game over. Do you want to play again? (yes/no)")

        response1 = recv(rfile1).strip().lower()
        response2 = recv(rfile2).strip().lower()

        if response1 != "yes" or response2 != "yes":
            send(wfile1, "[INFO] Game ended. Thanks for playing!")
            send(wfile2, "[INFO] Game ended. Thanks for playing!")

            player1[0].close()
            player2[0].close()

            print("[INFO] Players disconnected.")
            break
```

logic for confirmation step
```
# battleship.py
def run_two_player_game_online(player1_io, player2_io):
    ...

            if guess.lower() == 'quit':
                send(p["w"], "You forfeited the game.")
                send(opponent["w"], "Opponent forfeited. You win!")
                
                # Send final boards to both players
                send_board(p["w"], p["board"])
                send_board(opponent["w"], opponent["board"])
                return

            try:
                row, col = parse_coordinate(guess)
                result, sunk_name = p["board"].fire_at(row, col)
                moves[current] += 1

                if result == 'hit':
                    if sunk_name:
                        send(p["w"], f"HIT! You sank the {sunk_name}!")
                        send(opponent["w"], f"{p['name']} sank your {sunk_name}!")
                    else:
                        send(p["w"], "HIT!")
                        send(opponent["w"], f"{p['name']} hit one of your ships!")
                    if p["board"].all_ships_sunk():
                        send(p["w"], f"Congratulations! You sank all ships in {moves[current]} moves.")
                        send(opponent["w"], "All your ships are sunk. You lose.")

                        # Send final boards to both players
                        send_board(p["w"], p["board"])
                        send_board(opponent["w"], opponent["board"])
                        return # Ends the game if all ships are sunk

```

Task 2-3:
To meet requireemnt the Tier 2.3 requirement we 
