# Battleships Project 

## Task 1 - Basic 2-Player Game with Concurrency in BEER     
Task 1-1:    
In the initial client implementation,message syncronization issues occurred due to a single-threaded input/output model, this model forced the implementation to have to alternate between reading from the server to prompting for user input. This led to mutliple issues particularly with server message delays. We addressed this issue by implementing threading to add concurrency to the client.py implementation. To also improve function modularity we specifically added the receive_messages function which was designed to constantly read from the server - this was done by executing the function within a daemon thread which was created in main, which is responsible for gathering user input, and run concurrently with the receive_messages function. Our multithreaded client implementation ensures clients can receive messages at any time while simultaneously guaranteeing no server messages are missed which aligns with task 1-1's specifications.

Task 1-2:   
The original server file design was only able to handle one client at a time and didn't make use of concurrency, to be able to comply with the task requirements of accepting two clients, we had to modify the server file to implement multi-threading. Using socket.accept in a while loop, our function waits until two clients are connected, then each accepted socket is wrapped using a read and write makefile. Once both clients are connected we store their connections in a list and start a new thread for them by calling the handle_clients function as the target and each client as its arguments. The handle_cients function handles the game between two connected players where each player is a tuple of their (conn, rfile, wfile), having this as a separate function called by main helped to improve the files modularity which aligns with task 1-2's requirements.     

Task 1-3:  
The core game functionality was implemented within the run_two_player_game_online which was in the battleship file but is called within the server file. For this function we used the same style for our implementation of run_two_player_game_online as run_single_player_game_locally used, but enabling interaction between two remote players. This choice was made so we could maintain consistency in the codebase (i.e. using the same send, send_board and recv functions). The actual implementation of the battleship mechanics is as follows; prompt the current player for a coordinate -> validate input using parse_coordinate -> call fire_at on the opponents board -> send the outcome to both players -> end the game when all_ships_sunk is true. The turn switching is handled by toggling the current index and the game ends gracefully by printing a win/loss message for each client then closing their sockets.

Task 1-4:   
The message exchange between the server / client currently follows a structured protocol using plain-text printed to the terminal. We chose this to maintain simplicity and readbailituy for players. Client commands are sent as plain text and we make use of the recv function to parse the messages and the send function to write messages between the server / client. We tried to keep our client / server messages in the same style in the run_two_player_game_online function as the run_single_player_game_online function to maintain consistency and minimialism as specified within the task1-3 requirements.

Task 1-5:   
In accordance with task 1-5, since we assume a stable connection, we have not actively handled disconnections in this implementation. Once the game is won or if a player disconnects / forfeits by typing quit, the game loop is exited and both connections are stopped by the server closing the sockets associated with each player using player1[0].close within the handle_clients function.

# TO DO    
## Task 2 - Gameplay Quality-of-Life & Scalability     
Task 2-1:   
...
