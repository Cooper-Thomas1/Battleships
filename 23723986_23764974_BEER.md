# Battleships Project 

## Task 1 - Basic 2-Player Game with Concurrency in BEER     
Task 1-1:    
In the initial client implementation,message syncronization issues occurred due to a single-threaded input/output model, this model forced the implementation to have to alternate between reading from the server to prompting for user input. This led to mutliple issues particularly with server message delays. We addressed this issue by implementing threading to add concurrency to the client.py implementation. To also improve function modularity we specifically added the receive_messages function which was designed to constantly read from the server - this was done by executing the function within a daemon thread which was created in main, which is responsible for gathering user input, and run concurrently with the receive_messages function. Our multithreaded client implementation ensures clients can receive messages at any time while simultaneously guaranteeing no server messages are missed which aligns with task 1-1's specifications.

```
# client.py file
def receive_messages(rfile):
    try:
        while True:
            line = rfile.readline()
            if not line:
                print("[INFO] Server disconnected.")
                break

            line = line.strip()

            if line == "GRID":
                # Begin reading board lines
                print("\n[Board]")
                while True:
                    board_line = rfile.readline()
                    if not board_line or board_line.strip() == "":
                        break
                    print(board_line.strip())
            else:
                # Normal message
                print(line)
    except Exception as e:
        print(f"[ERROR] An error occurred in the receive thread: {e}")

def main():
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.connect((HOST, PORT))
        rfile = s.makefile('r')
        wfile = s.makefile('w')
        
        receive_thread = threading.Thread(target=receive_messages, args=(rfile,), daemon=True).start()

        try:
            while True:
                user_input = input(">> ")
                wfile.write(user_input + '\n')
                wfile.flush()

        except KeyboardInterrupt:
            print("\n[INFO] Exiting...")

        finally:
            s.close()
```

Task 1-2:   
The original server file design was only able to handle one client at a time and didn't make use of concurrency, to be able to comply with the task requirements of accepting two clients, we had to modify the server file to implement multi-threading. Using socket.accept in a while loop, our function waits until two clients are connected, then each accepted socket is wrapped using a read and write makefile. Once both clients are connected we store their connections in a list and start a new thread for them by calling the handle_clients function as the target and each client as its arguments. The handle_cients function handles the game between two connected players where each player is a tuple of their (conn, rfile, wfile), having this as a separate function called by main helped to improve the files modularity which aligns with task 1-2's requirements.    

```
# server.py file
def handle_clients(player1, player2):
    """
    Handles the game between two connected players.
    Each player is a tuple of (conn, rfile, wfile).
    """
    print("[INFO] Starting two-player game...")

    # Extract readable/writable file objects
    rfile1, wfile1 = player1[1], player1[2]
    rfile2, wfile2 = player2[1], player2[2]

    run_two_player_game_online((rfile1, wfile1), (rfile2, wfile2))

    player1[0].close()
    player2[0].close()
    print("[INFO] Game over. Connections closed.")

def main():
    """
    Accepts exactly two clients, then starts the game.
    """
    print(f"[INFO] Server listening on {HOST}:{PORT}")
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.bind((HOST, PORT))
        s.listen(2)

        players = []

        while len(players) < 2:
            conn, addr = s.accept()
            print(f"[INFO] Player {len(players) + 1} connected from {addr}")
            rfile = conn.makefile('r')
            wfile = conn.makefile('w')
            players.append((conn, rfile, wfile))

        # Start game in a separate thread (optional, makes future expansion easier)
        threading.Thread(target=handle_clients, args=(players[0], players[1])).start()
```

Task 1-3:  
The core game functionality was implemented within the run_two_player_game_online which was in the battleship file but is called within the server file. For this function we used the same style for our implementation of run_two_player_game_online as run_single_player_game_locally used, but enabling interaction between two remote players. This choice was made so we could maintain consistency in the codebase (i.e. using the same send, send_board and recv functions). The actual implementation of the battleship mechanics is as follows; prompt the current player for a coordinate -> validate input using parse_coordinate -> call fire_at on the opponents board -> send the outcome to both players -> end the game when all_ships_sunk is true. The turn switching is handled by toggling the current index and the game ends gracefully by printing a win/loss message for each client then closing their sockets.

```
# battleship.py file
def run_two_player_game_online(player1_io, player2_io):
    """
    Runs a turn-based Battleship game between two online players.
    Each player_io is a tuple of (rfile, wfile) file-like objects.
    """

    rfile1, wfile1 = player1_io
    rfile2, wfile2 = player2_io

    board1 = Board(BOARD_SIZE)
    board2 = Board(BOARD_SIZE)
    board1.place_ships_randomly(SHIPS)
    board2.place_ships_randomly(SHIPS)

def send(wfile, msg):
    wfile.write(msg + '\n')
    wfile.flush()

def send_board(wfile, board):
    wfile.write("GRID\n")
    wfile.write("  " + " ".join(str(i + 1).rjust(2) for i in range(board.size)) + '\n')
    for r in range(board.size):
        row_label = chr(ord('A') + r)
        row_str = " ".join(board.display_grid[r][c] for c in range(board.size))
        wfile.write(f"{row_label:2} {row_str}\n")
    wfile.write('\n')
    wfile.flush()

def recv(rfile):
    return rfile.readline().strip()

players = [
    {"name": "Player 1", "r": rfile1, "w": wfile1, "board": board2}, # Fires at player 2’s board
    {"name": "Player 2", "r": rfile2, "w": wfile2, "board": board1} # Fires at player 1’s board
]

for p in players:
    send(p["w"], f"Welcome {p['name']}! Game is starting now. Type 'quit' to exit.\n")

current = 0  # Index of current player
moves = [0, 0]  # Track moves per player

while True:
    p = players[current]
    opponent = players[1 - current]

    send_board(p["w"], p["board"])
    send(p["w"], "Your turn. Enter coordinate to fire at (e.g., B5):")

    guess = recv(p["r"])
    if guess.lower() == 'quit':
        send(p["w"], "You forfeited the game.")
        send(opponent["w"], "Opponent forfeited. You win!")
        break

    try:
        row, col = parse_coordinate(guess)
        result, sunk_name = p["board"].fire_at(row, col)
        moves[current] += 1

        if result == 'hit':
            if sunk_name:
                send(p["w"], f"HIT! You sank the {sunk_name}!")
                send(opponent["w"], f"{p['name']} sank your {sunk_name}!")
            else:
                send(p["w"], "HIT!")
                send(opponent["w"], f"{p['name']} hit one of your ships!")
            if p["board"].all_ships_sunk():
                send(p["w"], f"Congratulations! You sank all ships in {moves[current]} moves.")
                send(opponent["w"], "All your ships are sunk. You lose.")
                break
        elif result == 'miss':
            send(p["w"], "MISS!")
            send(opponent["w"], f"{p['name']} missed.")
            current = 1 - current  # Switch turns
        elif result == 'already_shot':
            send(p["w"], "You've already fired at that location. Try again.")
    except ValueError as e:
        send(p["w"], f"Invalid input: {e}")
```

Task 1-4:   
The message exchange between the server / client currently follows a structured protocol using plain-text printed to the terminal. We chose this to maintain simplicity and readability for players. Client commands are sent as plain text and we make use of the recv function to parse the messages and the send function to write messages between the server / client. We tried to keep our client / server messages in the same style in the run_two_player_game_online function as the run_single_player_game_online function to maintain consistency and minimialism as specified within the task1-3 requirements.

```
# battleship.py file
def send(wfile, msg):
        wfile.write(msg + '\n')
        wfile.flush()

def recv(rfile):
    return rfile.readline().strip()
```

Task 1-5:   
In accordance with task 1-5, since we assume a stable connection, we have not actively handled disconnections in this implementation. Once the game is won or if a player disconnects / forfeits by typing quit, the game loop is exited and both connections are stopped by the server closing the sockets associated with each player using player1[0].close within the handle_clients function.

```
# server.py file
run_two_player_game_online((rfile1, wfile1), (rfile2, wfile2))

player1[0].close()
player2[0].close()
print("[INFO] Game over. Connections closed.")
```

# TO DO    
## Task 2 - Gameplay Quality-of-Life & Scalability     
Task 2-1:   
...
